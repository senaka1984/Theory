ðŸ“Œ ðŸ’° ðŸ’µ ðŸ’¸ ðŸ’³ ðŸ“‰ ðŸ“ˆ ðŸ’¹ ðŸ’² ðŸ§¾ ðŸ“„ ðŸ“ ðŸ–Š ðŸ—‚ ðŸ§  âš  â— âœ… âŒ ðŸ“Œ ðŸ” ðŸ‘¨â€ðŸ’¼ ðŸ‘” ðŸ§‘ ðŸ§‘ ðŸ’¼ ðŸ“ðŸ§³ ðŸ¡ ðŸ§  ðŸŽ¯ ðŸ›‘ âœ… ðŸ’¡

how it works, when to use it, how it differs from other hooks, and real-world examples.

ðŸ” What is useCallback?

const memoizedCallback = useCallback(fn, deps);

useCallback returns a memoized version of the callback function fn that only changes if dependencies (deps) change.


âš™ï¸ Why use useCallback?

	ðŸ” Every time a component re-renders, all functions inside it are re-created. This can cause:

	ðŸ” Unnecessary renders in child components (especially those wrapped in React.memo)

	ðŸ” Breaking referential equality checks in dependencies (e.g., in useEffect, useMemo)

	ðŸ” useCallback prevents this by preserving the same function reference.
	
	
ðŸ§ª Basic Example

const Parent = () => {
  const [count, setCount] = useState(0);

  const handleClick = useCallback(() => {
    console.log("Clicked!");
  }, []); // No dependencies, function stays the same

  return (
    <>
      <button onClick={() => setCount(c => c + 1)}>Increment</button>
      <Child onClick={handleClick} />
    </>
  );
};

const Child = React.memo(({ onClick }) => {
  console.log("Child rendered");
  return <button onClick={onClick}>Child Button</button>;
});


Without useCallback, handleClick would be recreated on every render â†’ Child would re-render every time.