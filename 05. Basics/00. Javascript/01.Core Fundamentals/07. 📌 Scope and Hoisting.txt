
ğŸ“Œ ğŸ’° ğŸ’µ ğŸ’¸ ğŸ’³ ğŸ“‰ ğŸ“ˆ ğŸ’¹ ğŸ’² ğŸ§¾ ğŸ“„ ğŸ“ ğŸ–Š ğŸ—‚ ğŸ§  âš  â— âœ… âŒ ğŸ“Œ ğŸ” ğŸ‘¨â€ğŸ’¼ ğŸ‘” ğŸ§‘ ğŸ§‘ ğŸ’¼ ğŸ“ğŸ§³ ğŸ¡ ğŸ§  ğŸ¯ ğŸ›‘ âœ… ğŸ’¡

ğŸ” JavaScript Scope and Hoisting Explained

ğŸ”¸ 1. Scope
Scope determines where variables, functions, and objects are accessible in your code.

ğŸ§­ Types of Scope

| Type               | Description                                                                       |
| ------------------ | --------------------------------------------------------------------------------- |
| **Global Scope**   | Declared outside any function/block â€” accessible everywhere.                      |
| **Function Scope** | Variables declared with `var` inside a function are visible only within it.       |
| **Block Scope**    | Variables declared with `let` or `const` are visible only within that block `{}`. |


ğŸ” Example

function testScope() {
  var a = 1;      // function-scoped
  let b = 2;      // block-scoped
  const c = 3;    // block-scoped

  if (true) {
    var a = 10;   // same scope as above, value overwritten
    let b = 20;   // new block scope
    const c = 30; // new block scope
    console.log(a, b, c); // 10 20 30
  }

  console.log(a); // 10
  console.log(b); // 2
  console.log(c); // 3
}


ğŸ”¸ 2. Hoisting

Hoisting is JavaScript's behavior of moving declarations to the top of their scope before code execution.

âš ï¸ But only the declarations are hoisted â€” not the initializations.

ğŸ“¦ Hoisting Behavior

| Keyword    | Hoisted | Initialized  | Scope          |
| ---------- | ------- | ------------ | -------------- |
| `var`      | âœ… Yes   | âŒ No         | Function scope |
| `let`      | âœ… Yes   | âŒ No (TDZ\*) | Block scope    |
| `const`    | âœ… Yes   | âŒ No (TDZ\*) | Block scope    |
| `function` | âœ… Yes   | âœ… Yes        | Function scope |

ğŸ”¸ TDZ = Temporal Dead Zone: You cannot access the variable before its declaration.


ğŸ§ª Hoisting Example

console.log(a); // undefined
var a = 5;

console.log(b); // ReferenceError: Cannot access 'b' before initialization
let b = 10;

var a;


ğŸ” Behind the scenes:

var a;
console.log(a); // undefined
a = 5;

let b;
console.log(b); // âŒ Error
b = 10;



ğŸ” Function Hoisting Example

sayHello(); // âœ… Works
function sayHello() {
  console.log("Hi!");
}

But not with function expressions:

sayHi(); // âŒ TypeError: sayHi is not a function
var sayHi = function() {
  console.log("Hello");
};

âœ… Summary

| Concept  | Key Takeaway                                                                                       |
| -------- | -------------------------------------------------------------------------------------------------- |
| Scope    | Controls variable access â€” `var` is function-scoped, `let` and `const` are block-scoped.           |
| Hoisting | Declarations are moved to the top â€” only `var` and `function` are safely usable before definition. |




ğŸ”¹ 1. Function Declarations â€” âœ… Fully Hoisted

âœ… Hoisted with both declaration and definition.

greet(); // âœ… Works, prints: Hello!

function greet() {
  console.log("Hello!");
}

Behind the scenes, JavaScript interprets it as:

function greet() {
  console.log("Hello!");
}
greet();

ğŸ”‘ Use Case: You can safely call a function before it's defined.


ğŸ”¹ 2. Function Expressions â€” âŒ Not Fully Hoisted

âŒ Only the variable (if declared with var) is hoisted â€” not the function itself.


sayHi(); // âŒ TypeError: sayHi is not a function

var sayHi = function() {
  console.log("Hi!");
};

Behind the scenes:

var sayHi; // hoisted
sayHi();   // âŒ Error, still undefined
sayHi = function() {
  console.log("Hi!");
};

ğŸ”‘ Key Insight: Function expressions behave like any other variable assignment.



ğŸ”¹ 4. Function Inside Block Scope

Function declarations in block scopes (if, while, etc.) are not always hoisted reliably, especially in non-strict mode or across browsers.

if (true) {
  function blockFn() {
    console.log("Inside block");
  }
}

blockFn(); // âŒ Might throw ReferenceError in strict mode

âœ… Best Practice: Use function expressions inside blocks to avoid ambiguity.



âœ… Summary Table: Hoisting in Functions

| Function Type                   | Hoisted?                 | Can Call Before Definition?   |
| ------------------------------- | -----------------------  | ---------------------------   |
| `function declaration`          | âœ… Yes                   | âœ… Yes                       |
| `var function expression`       | ğŸŸ¡ Partially (var only)    âŒ No                        |
| `let/const function expression` | âŒ No                    | âŒ No                        |
| `arrow function`                | âŒ No                    | âŒ No                        |
| Block-scoped functions          | ğŸŸ  Browser-dependent     | âŒ Unsafe                    |





-----------------------------------------------------------------------------------------------------------------------------------------------------

Hereâ€™s a clear, side-by-side example set that demonstrates hoisting behavior for each type of function in JavaScript, including console.log() outputs and expected results.


ğŸŸ¢ 1. Function Declaration

			greet(); // âœ… Works: "Hello from declaration!"

			function greet() {
			console.log("Hello from declaration!");
			}
			
		âœ… Fully hoisted (both name and definition)


ğŸŸ¡ 2. var Function Expression

		console.log(sayHi); // undefined
		sayHi(); // âŒ TypeError: sayHi is not a function
		
		var sayHi = function() {
		console.log("Hi from var function expression!");
		};

		ğŸ”¸ Only the variable sayHi is hoisted, not the function value.


ğŸ”´ 3. let / const Function Expression

	console.log(sayHello); // âŒ ReferenceError: Cannot access 'sayHello' before initialization
		const sayHello = function() {
		console.log("Hello from const function expression!");
	};

	console.log(sayYo); // âŒ ReferenceError
		let sayYo = function() {
		console.log("Yo from let function expression!");
	};
	
	âŒ Not hoisted (TDZ: Temporal Dead Zone applies)
	

ğŸ”» 4. Arrow Function (with var)

	console.log(arrow); // undefined
	arrow(); // âŒ TypeError: arrow is not a function

	var arrow = () => {
		console.log("Arrow function here!");
	};

	ğŸ”¸ Same as var function expression â€” only the variable is hoisted.


ğŸŸ  5. Block-Scoped Function Declaration

	if (true) {
		function testBlock() {
		console.log("Inside block-scoped function");
	}	
}

testBlock(); // âŒ ReferenceError in strict mode, might work in sloppy mode


âš ï¸ Behavior is browser- and mode-dependent (ES6+ strict mode disallows block-level hoisting of functions).

To make it safe:

if (true) {
  const testSafe = function () {
    console.log("Safe block-level function");
  };
}

testSafe(); // âŒ ReferenceError: testSafe is not defined


âœ… Summary

| Function Type                     | Can Call Before Declaration? | Hoisted?     | Notes                         |
| --------------------------------- | ---------------------------- | ------------ | ----------------------------- |
| Function Declaration              | âœ… Yes                        | âœ… Yes        | Safe to call early            |
| `var` Function Expression         | âŒ No                         | ğŸŸ¡ Partially | Only name hoisted (undefined) |
| `let` / `const` Function Expr.    | âŒ No                         | âŒ No         | TDZ applies                   |
| Arrow Function (var/let/const)    | âŒ No                         | âŒ No         | Same as function expressions  |
| Block-Scoped Function Declaration | âŒ No                         | ğŸŸ  Partial   | Strict mode = ReferenceError  |





===============================================================================================================================

CHECK THIS

1.  This will work â€” and hereâ€™s why:
 
 
 if (true) {
  var blockFn = function blockFn() { 
    console.log("Inside block");
  }
}

blockFn(); // âœ… Outputs: Inside block



 
2.  will NOT actually work as expected 


blockFn(); // âœ… Outputs: Inside block

if (true) {
  var blockFn = function blockFn() { 
    console.log("Inside block");
  }
}

ğŸš« Contrast: Using let or const instead

if (true) {
  let blockFn = function blockFn() {
    console.log("Inside block");
  }
}

blockFn(); // âŒ ReferenceError


